
// ######################################################################## //
//
//  本程序使用动态规划法解决 '最大 k 乘积' 问题.
//
//  创建日期: 2016-04-03
//
//  修改记录:
//  ( 1 ) 2016-04-03 创建了初始版本( v0.10 )
//
//  版 本 号: v0.10
//
//  备    注: 使用标准 C 代码实现
//
//  作    者: 刘伟
//
// ######################################################################## //

// 使用的库定义
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<iostream>
using namespace std;

// ######################################################################## //
//                                                                          // 
//                              下面是数据定义区                               // 
//                                                                          // 
// ######################################################################## //

#define STR_LEN 100
#define TRUE    1
#define FALSE   0

//////////////////////////////////////////////////////////////////////////////


// ######################################################################## //
//                                                                          // 
//                           下面是各个子函数定义                               // 
//                                                                          // 
// ######################################################################## //

int  CalcMaxKProduct(int n, int k, int **D, int **P);
void PrintProductMatrix(int n, int k, int **D, int **P);

//////////////////////////////////////////////////////////////////////////////

// ######################################################################## //
//                                                                          // 
//                          下面是各个子函数的实现                             // 
//                                                                          // 
// ######################################################################## //
//
// 测试数据如下 :
// ( 1 ) 1234 划分为 3 段 : 12 * 3 * 4 = 144
// ( 2 ) 自行设计 2 个测试用例
int CalcMaxKProduct(int n, int k, int **D, int **P)
{
	int i, j, kp;
	for (i = 1; i <= n; ++i) {
		P[i][1] = D[1][i];

	}

	for (i = 1; i <= n; ++i) {
		for (kp = 2; kp <= k; ++kp) {
			P[i][kp] = 0;
			for (j = kp - 1; j <= i - 1; ++j) {
				if (P[i][kp] < P[j][kp - 1] * D[j + 1][i])
					P[i][kp] = P[j][kp - 1] * D[j + 1][i];
			}
		}
	}
	return P[n][k];
}

// 打印矩阵 ...
void PrintProductMatrix(int n, int k, int **D, int **P)
{
	int i, j;

	// 打印 'D' ...
	printf("\t生成的整数分段值矩阵为 : \n");

	// 请将下面的代码补充完毕, 使程序可以正确运行 ...
	cout << "[i]位到<j>位生成的整数";
	for (j = 1; j <= n; ++j)
		cout << "\t" <<"<"<< j<<">";
	cout << endl;
	for (i = 1; i <= n; i++)
	{
		cout << "[" << i << "]\t\t\t";
		for (j = 1; j <= n; j++)
		{
			printf("%d\t", D[i][j]);
		}
		printf("\n");
	}

	printf("\n\n");

	// 打印 'P' ...
	printf("\t生成的分段乘积矩阵为 : \n");

	// 请将下面的代码补充完毕, 使程序可以正确运行 ...
	cout <<"前[i]位分成<j>段";
	for (j = 1; j <= k; j++)
		cout << "\t" << "<"<<j<<">";
	cout << "\n";
	for (i = 1; i <= n; i++)
	{	
		cout << "  ["<<i<<"]"<<"\t\t\t ";
		for (j = 1; j <= k; j++)
		{
			if(i+0 == n && j+0 == k)
				printf(">%d<\t", P[i][j]);
			else
				printf("%d\t ", P[i][j]);
		}
		printf("\n");
	}

	printf("\n\n");
}

//////////////////////////////////////////////////////////////////////////////

// ######################################################################## //
//                                                                          // 
//                             下面是主程序的实现                              // 
//                                                                          // 
// ######################################################################## //

int main(void)
{
	char StrI[STR_LEN];
	char StrK[STR_LEN];
	int  *I, n;    // 储存输入的整数及其长度 ...
	int  k;        // 输入的整数分为 'k' 段 ...
	int  **D, **P; // 二维数组, 储存整数的各个分段值及乘积值 ...
	int  i, j, MaxProduct;
	int  IsStop;
	IsStop = FALSE;
	while (!IsStop)
	{
		// 清屏 ...
		system("cls");

		// 输入整数 'I' ...
		printf("\n\n\t请输入 < 整数 I 的值 > ， 输入 < q / Q > 表示结束 : ");
		cin >> StrI;
		//scanf("%s", StrI);
		n = strlen(StrI); // 输入整数的位数 ...
		if (n > 0)
			IsStop = ((StrI[0] == 'q') || (StrI[0] == 'Q'));
		else
			printf("\t输入的整数不能为空 !\n\n");

		if (!IsStop)
		{
			// 输入分段数 'k' ...
			printf("\n\t请输入 < 整数分段数 k > ， 输入 < q / Q > 表示结束 : ");
			cin >> StrK;
			//scanf("%s", StrK);
			if (strlen(StrK) > 0)
				IsStop = ((StrK[0] == 'q') || (StrK[0] == 'Q'));
			else
				printf("\t输入的整数分段数不能为空 !\n\n");

			// 输入的整数及其分段数 'I' 和 'k' 均不为空, 则计算最大 'k' 乘积 ...
			if (!IsStop)
			{
				// 将输入的字符串转换为整数 ...

				// 输入的整数 'I' ...

				// 动态申请一维数组 ...
				I = (int *)malloc((n + 1) * sizeof(int));

				// 将输入的字符串整数的每一位放入 'I' 中 ...
				for (i = 1; i <= n; i++)
					I[i] = StrI[i - 1] - '0'; // 注意序号起始值 ...

											  // 输入的分段数 'k' ...
				k = atoi(StrK);

				// 动态申请二维数组 'D' 和 'P' ...

				// 'D' - 储存整数的各个分段值( n x n 阵 ) ...
				D = (int **)malloc((n + 1) * sizeof(int));
				for (i = 0; i <= n; i++)
					D[i] = (int *)malloc((n + 1) * sizeof(int));
				// 初始化 ...
			
				for (i = 0; i <= n; i++)
					for (j = 0; j <= n; j++)
						D[i][j] = 0;

				// 'P' - 储存整数的分段乘积值( n x k 阵 ) ...
				P = (int **)malloc((n + 1) * sizeof(int));
				for (i = 0; i <= n; i++)
					P[i] = (int *)malloc((k + 1) * sizeof(int));
				// 初始化 ...
			//	for (i = 0; i <= n; i++)
			//		for (j = 0; j <= k; j++)
			//			P[i][j] = 0;

				// 生成 'D' 矩阵 ...
				for (i = 1; i <= n; i++)
				{
					D[i][i] = I[i];
				}
				for (i = 1; i <= n; i++)
				{
					for (j = i + 1; j <= n; j++)
					{
						D[i][j] = D[i][j - 1] * 10 + D[j][j];
					}
				}

				// 请将下面的代码补充完毕, 使程序可以正确运行 ...
				// ......

				// 计算最大 'k' 乘积 ...
				MaxProduct = CalcMaxKProduct(n, k, D, P);

				// 显示计算结果 ...
				printf("\n\t< 计算得到的最大 k 乘积为：%d > \n\n", MaxProduct);

				// 打印数值矩阵 ...
				PrintProductMatrix(n, k, D, P);

				// 释放二维数组 'D' 和 'P' 的空间 ...
				for (i = 0; i <= n; i++)
					free(D[i]);
				free(D);

				for (i = 0; i <= n; i++)
					free(P[i]);
				free(P);

				// 等待用户输入任意一键返回 ...
				printf("\n\n");
				system("PAUSE");
			}
		}
	}

	// 等待用户输入任意一键返回 ...
	printf("\n\n");
	system("PAUSE");
}

//////////////////////////////////////////////////////////////////////////////
